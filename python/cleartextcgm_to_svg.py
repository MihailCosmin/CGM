#!/usr/bin/env python3
"""
Clear Text CGM to SVG Converter
Converts clear text CGM files to Scalable Vector Graphics (SVG) format

This converter parses clear text CGM files (as generated by our binary CGM converter)
and creates corresponding SVG files that can be viewed in web browsers or graphics applications.

Usage:
    python cleartextcgm_to_svg.py input.CGM output.svg
    python cleartextcgm_to_svg.py input.CGM  # outputs to input.svg

Supported CGM Commands:
- BEGMF, BEGPIC, BEGPICBODY (structure)
- vdcext (viewport/coordinate system)
- LINE (polylines)
- DISJTLINE (disjoint polylines)
- TEXT (text elements)
- POLYGON (filled polygons)
- linewidth, linetype, linecolr (line attributes)
- textfontindex, charheight, textcolr (text attributes)
- fillcolr (fill attributes)

Color Support:
- Indexed colors (0-255)
- Direct RGB colors
- Default CGM color palette

Coordinate System:
- Automatically scales CGM coordinates to fit SVG viewport
- Preserves aspect ratio
- Configurable output dimensions
"""

import sys
import os
import re
from typing import List, Optional
from dataclasses import dataclass
from enum import Enum


class LineType(Enum):
    """CGM Line Types"""
    SOLID = 1
    DASH = 2
    DOT = 3
    DASH_DOT = 4
    DASH_DOT_DOT = 5


@dataclass
class Point:
    """2D Point"""
    x: float
    y: float
    
    def __str__(self):
        return f"{self.x},{self.y}"


@dataclass
class Color:
    """RGB Color"""
    r: int
    g: int
    b: int
    
    def to_hex(self) -> str:
        """Convert to hex color string"""
        return f"#{self.r:02x}{self.g:02x}{self.b:02x}"
    
    @classmethod
    def from_index(cls, index: int) -> 'Color':
        """Create color from CGM color index using standard palette"""
        # Standard CGM color palette
        palette = [
            (255, 255, 255),  # 0: White (background)
            (0, 0, 0),        # 1: Black
            (255, 0, 0),      # 2: Red
            (0, 255, 0),      # 3: Green
            (0, 0, 255),      # 4: Blue
            (255, 255, 0),    # 5: Yellow
            (255, 0, 255),    # 6: Magenta
            (0, 255, 255),    # 7: Cyan
            (128, 128, 128),  # 8: Gray
            (192, 192, 192),  # 9: Light Gray
            (128, 0, 0),      # 10: Dark Red
            (0, 128, 0),      # 11: Dark Green
            (0, 0, 128),      # 12: Dark Blue
            (128, 128, 0),    # 13: Dark Yellow
            (128, 0, 128),    # 14: Dark Magenta
            (0, 128, 128),    # 15: Dark Cyan
        ]
        
        if 0 <= index < len(palette):
            r, g, b = palette[index]
        else:
            # Generate a color for higher indices
            r = (index * 37) % 256
            g = (index * 73) % 256
            b = (index * 109) % 256
        
        return cls(r, g, b)


class GraphicsState:
    """Current graphics state"""
    def __init__(self):
        self.line_width: float = 1.0
        self.line_type: LineType = LineType.SOLID
        self.line_color: Color = Color(0, 0, 0)  # Black
        self.text_color: Color = Color(0, 0, 0)  # Black
        self.fill_color: Color = Color(255, 255, 255)  # White
        self.text_font_index: int = 1
        self.character_height: float = 12.0
        self.background_color: Color = Color(255, 255, 255)  # White


class CGMToSVGConverter:
    """Converts clear text CGM to SVG"""
    
    def __init__(self, width: int = 800, height: int = 600):
        self.svg_width = width
        self.svg_height = height
        self.elements: List[str] = []
        self.state = GraphicsState()
        
        # CGM coordinate system
        self.vdc_extent_min = Point(0, 0)
        self.vdc_extent_max = Point(1000, 1000)
        
        # Font mapping
        self.font_families = {
            1: "Arial, sans-serif",
            2: "Times, serif",
            3: "Courier, monospace",
            14: "Arial, sans-serif",  # Common in technical drawings
        }
    
    def convert_file(self, cgm_file: str, svg_file: str):
        """Convert a clear text CGM file to SVG"""
        with open(cgm_file, 'r', encoding='cp1252') as f:
            content = f.read()
        
        # Parse CGM content
        self._parse_cgm(content)
        
        # Generate SVG
        svg_content = self._generate_svg()
        
        # Write SVG file
        with open(svg_file, 'w', encoding='utf-8') as f:
            f.write(svg_content)
    
    def _parse_cgm(self, content: str):
        """Parse clear text CGM content"""
        lines = content.split('\n')
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('%'):
                continue
            
            # Remove trailing semicolon
            if line.endswith(';'):
                line = line[:-1]
            
            self._parse_command(line)
    
    def _parse_command(self, line: str):
        """Parse a single CGM command"""
        # Handle different command types
        if line.startswith('BEGMF'):
            self._parse_begin_metafile(line)
        elif line.startswith('BEGPIC'):
            self._parse_begin_picture(line)
        elif line.startswith('vdcext'):
            self._parse_vdc_extent(line)
        elif line.startswith('LINE'):
            self._parse_line(line)
        elif line.startswith('DISJTLINE'):
            self._parse_disjoint_line(line)
        elif line.startswith('TEXT'):
            self._parse_text(line)
        elif line.startswith('POLYGON'):
            self._parse_polygon(line)
        elif line.startswith('linewidth'):
            self._parse_line_width(line)
        elif line.startswith('linetype'):
            self._parse_line_type(line)
        elif line.startswith('linecolr'):
            self._parse_line_color(line)
        elif line.startswith('textcolr'):
            self._parse_text_color(line)
        elif line.startswith('fillcolr'):
            self._parse_fill_color(line)
        elif line.startswith('textfontindex'):
            self._parse_text_font_index(line)
        elif line.startswith('charheight'):
            self._parse_character_height(line)
        # Add more command parsers as needed
    
    def _parse_begin_metafile(self, line: str):
        """Parse BEGMF command"""
        # Extract title if present
        match = re.search(r"'([^']*)'", line)
        if match:
            title = match.group(1)
            # Sanitize title for XML comments (replace -- with - -)
            safe_title = title.replace('--', '- -')
            self.elements.append(f'<!-- Metafile: {safe_title} -->')
    
    def _parse_begin_picture(self, line: str):
        """Parse BEGPIC command"""
        # Extract picture name if present
        match = re.search(r"'([^']*)'", line)
        if match:
            picture_name = match.group(1)
            # Sanitize picture name for XML comments (replace -- with - -)
            safe_name = picture_name.replace('--', '- -')
            self.elements.append(f'<!-- Picture: {safe_name} -->')
    
    def _parse_vdc_extent(self, line: str):
        """Parse vdcext command to set coordinate system"""
        # Extract coordinates: vdcext (x1,y1) (x2,y2)
        coords = re.findall(r'\(([^)]+)\)', line)
        if len(coords) >= 2:
            x1, y1 = map(float, coords[0].split(','))
            x2, y2 = map(float, coords[1].split(','))
            self.vdc_extent_min = Point(x1, y1)
            self.vdc_extent_max = Point(x2, y2)
    
    def _parse_line(self, line: str):
        """Parse LINE command (polyline)"""
        points = self._extract_points(line)
        if len(points) < 2:
            return
        
        svg_points = [self._transform_point(p) for p in points]
        path_data = f"M {svg_points[0]}"
        for point in svg_points[1:]:
            path_data += f" L {point}"
        
        style = self._get_line_style()
        self.elements.append(f'<path d="{path_data}" {style} fill="none"/>')
    
    def _parse_disjoint_line(self, line: str):
        """Parse DISJTLINE command (multiple separate line segments)"""
        points = self._extract_points(line)
        if len(points) < 2:
            return
        
        style = self._get_line_style()
        
        # Draw line segments (every 2 points form a segment)
        for i in range(0, len(points) - 1, 2):
            if i + 1 < len(points):
                p1 = self._transform_point(points[i])
                p2 = self._transform_point(points[i + 1])
                path_data = f"M {p1} L {p2}"
                path_element = f'<path d="{path_data}" {style} fill="none"/>'
                self.elements.append(path_element)
    
    def _parse_text(self, line: str):
        """Parse TEXT command"""
        # Extract position and text: TEXT (x,y) final 'text'
        coord_match = re.search(r'\(([^)]+)\)', line)
        text_match = re.search(r"'([^']*)'", line)
        
        if coord_match and text_match:
            x, y = map(float, coord_match.group(1).split(','))
            text_content = text_match.group(1)
            
            svg_point = self._transform_point(Point(x, y))
            font_family = self.font_families.get(
                self.state.text_font_index, "Arial, sans-serif")
            
            # Calculate font size (approximate conversion from CGM height)
            font_size = self._transform_length(self.state.character_height)
            
            text_style = (f'fill="{self.state.text_color.to_hex()}" '
                          f'font-family="{font_family}" '
                          f'font-size="{font_size}px"')
            
            # Escape XML special characters
            # Escape XML special characters
            text_content = (text_content.replace('&', '&amp;')
                            .replace('<', '&lt;').replace('>', '&gt;'))
            
            text_element = (f'<text x="{svg_point.x}" y="{svg_point.y}" '
                            f'{text_style}>{text_content}</text>')
            self.elements.append(text_element)
    
    def _parse_polygon(self, line: str):
        """Parse POLYGON command"""
        points = self._extract_points(line)
        if len(points) < 3:
            return
        
        svg_points = [self._transform_point(p) for p in points]
        points_str = ' '.join(str(p) for p in svg_points)
        
        line_style = self._get_line_style()
        fill_style = f'fill="{self.state.fill_color.to_hex()}"'
        
        polygon_element = (f'<polygon points="{points_str}" '
                           f'{line_style} {fill_style}/>')
        self.elements.append(polygon_element)
    
    def _parse_line_width(self, line: str):
        """Parse linewidth command"""
        match = re.search(r'linewidth\s+([\d.]+)', line)
        if match:
            self.state.line_width = float(match.group(1))
    
    def _parse_line_type(self, line: str):
        """Parse linetype command"""
        match = re.search(r'linetype\s+(\d+)', line)
        if match:
            line_type_num = int(match.group(1))
            try:
                self.state.line_type = LineType(line_type_num)
            except ValueError:
                self.state.line_type = LineType.SOLID
    
    def _parse_line_color(self, line: str):
        """Parse linecolr command"""
        color = self._parse_color(line)
        if color:
            self.state.line_color = color
    
    def _parse_text_color(self, line: str):
        """Parse textcolr command"""
        color = self._parse_color(line)
        if color:
            self.state.text_color = color
    
    def _parse_fill_color(self, line: str):
        """Parse fillcolr command"""
        color = self._parse_color(line)
        if color:
            self.state.fill_color = color
    
    def _parse_text_font_index(self, line: str):
        """Parse textfontindex command"""
        match = re.search(r'textfontindex\s+(\d+)', line)
        if match:
            self.state.text_font_index = int(match.group(1))
    
    def _parse_character_height(self, line: str):
        """Parse charheight command"""
        match = re.search(r'charheight\s+([\d.]+)', line)
        if match:
            self.state.character_height = float(match.group(1))
    
    def _parse_color(self, line: str) -> Optional[Color]:
        """Parse color specification (indexed or direct RGB)"""
        # Try indexed color first: colorcommand 5
        index_match = re.search(r'\s+(\d+)$', line)
        if index_match:
            index = int(index_match.group(1))
            return Color.from_index(index)
        
        # Try direct RGB: colorcommand 255 128 64
        rgb_match = re.search(r'\s+(\d+)\s+(\d+)\s+(\d+)$', line)
        if rgb_match:
            r, g, b = map(int, rgb_match.groups())
            return Color(r, g, b)
        
        return None
    
    def _extract_points(self, line: str) -> List[Point]:
        """Extract coordinate points from a line"""
        points = []
        # Find all coordinate pairs in parentheses
        coords = re.findall(r'\(([^)]+)\)', line)
        for coord in coords:
            try:
                x, y = map(float, coord.split(','))
                points.append(Point(x, y))
            except (ValueError, IndexError):
                continue
        return points
    
    def _transform_point(self, cgm_point: Point) -> Point:
        """Transform CGM coordinates to SVG coordinates"""
        # Calculate scale factors
        cgm_width = self.vdc_extent_max.x - self.vdc_extent_min.x
        cgm_height = self.vdc_extent_max.y - self.vdc_extent_min.y
        
        if cgm_width <= 0 or cgm_height <= 0:
            return Point(0, 0)
        
        # Preserve aspect ratio
        scale_x = self.svg_width / cgm_width
        scale_y = self.svg_height / cgm_height
        scale = min(scale_x, scale_y)
        
        # Center the drawing
        svg_width_used = cgm_width * scale
        svg_height_used = cgm_height * scale
        offset_x = (self.svg_width - svg_width_used) / 2
        offset_y = (self.svg_height - svg_height_used) / 2
        
        # Transform coordinates
        x = (cgm_point.x - self.vdc_extent_min.x) * scale + offset_x
        y = (cgm_point.y - self.vdc_extent_min.y) * scale + offset_y
        
        # Flip Y axis (CGM has origin at bottom-left, SVG at top-left)
        y = self.svg_height - y
        
        return Point(x, y)
    
    def _transform_length(self, cgm_length: float) -> float:
        """Transform CGM length to SVG length"""
        cgm_width = self.vdc_extent_max.x - self.vdc_extent_min.x
        cgm_height = self.vdc_extent_max.y - self.vdc_extent_min.y
        
        if cgm_width <= 0 or cgm_height <= 0:
            return cgm_length
        
        scale_x = self.svg_width / cgm_width
        scale_y = self.svg_height / cgm_height
        scale = min(scale_x, scale_y)
        
        return cgm_length * scale
    
    def _get_line_style(self) -> str:
        """Generate SVG style string for current line attributes"""
        width = self._transform_length(self.state.line_width)
        color = self.state.line_color.to_hex()
        
        # Handle line types
        if self.state.line_type == LineType.SOLID:
            stroke_dasharray = "none"
        elif self.state.line_type == LineType.DASH:
            dash_length = width * 4
            stroke_dasharray = f"{dash_length},{dash_length}"
        elif self.state.line_type == LineType.DOT:
            dot_length = width
            stroke_dasharray = f"{dot_length},{dot_length}"
        elif self.state.line_type == LineType.DASH_DOT:
            dash_length = width * 4
            dot_length = width
            stroke_dasharray = f"{dash_length},{dot_length},{dot_length},{dot_length}"
        elif self.state.line_type == LineType.DASH_DOT_DOT:
            dash_length = width * 4
            dot_length = width
            stroke_dasharray = f"{dash_length},{dot_length},{dot_length},{dot_length},{dot_length},{dot_length}"
        else:
            stroke_dasharray = "none"
        
        style = f'stroke="{color}" stroke-width="{width:.2f}"'
        if stroke_dasharray != "none":
            style += f' stroke-dasharray="{stroke_dasharray}"'
        
        return style
    
    def _generate_svg(self) -> str:
        """Generate complete SVG content"""
        svg_header = f'''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="{self.svg_width}" height="{self.svg_height}"
     viewBox="0 0 {self.svg_width} {self.svg_height}">
<!-- Generated from Clear Text CGM -->
<rect width="{self.svg_width}" height="{self.svg_height}" 
      fill="{self.state.background_color.to_hex()}"/>
'''
        
        svg_footer = '</svg>'
        
        return svg_header + '\n'.join(self.elements) + '\n' + svg_footer


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: python cleartextcgm_to_svg.py <input.CGM> [output.svg] [width] [height]")
        print("\\nExample:")
        print("  python cleartextcgm_to_svg.py techdraw_cleartext.CGM techdraw.svg")
        print("  python cleartextcgm_to_svg.py drawing.CGM drawing.svg 1200 800")
        print("  python cleartextcgm_to_svg.py drawing.CGM  # creates drawing.svg")
        sys.exit(1)
    
    input_file = sys.argv[1]
    
    # Check if input file exists
    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' not found!")
        sys.exit(1)
    
    # Determine output filename
    if len(sys.argv) >= 3:
        output_file = sys.argv[2]
    else:
        # Replace extension with .svg
        base_name = os.path.splitext(input_file)[0]
        output_file = base_name + ".svg"
    
    # Get dimensions
    width = int(sys.argv[3]) if len(sys.argv) >= 4 else 800
    height = int(sys.argv[4]) if len(sys.argv) >= 5 else 600
    
    print(f"Converting Clear Text CGM to SVG:")
    print(f"  Input:      {input_file}")
    print(f"  Output:     {output_file}")
    print(f"  Dimensions: {width} x {height}")
    print()
    
    try:
        # Perform conversion
        converter = CGMToSVGConverter(width, height)
        converter.convert_file(input_file, output_file)
        
        print(f"Conversion completed successfully!")
        print(f"SVG file written to: {output_file}")
        
        # Report statistics
        with open(output_file, 'r') as f:
            svg_content = f.read()
            element_count = svg_content.count('<path') + svg_content.count('<text') + svg_content.count('<polygon')
            print(f"Generated {element_count} SVG elements")
        
    except Exception as e:
        print(f"Error during conversion: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def test_conversion():
    """Test the conversion with sample CGM files"""
    test_files = [
        "tests/00003/techdraw_cleartext.CGM",
        "tests/00003/ICN-AFGA08298XX-A-252001-A-D1131-00007-A-01-1_cleartext.CGM"
    ]
    
    for test_file in test_files:
        if os.path.exists(test_file):
            print(f"Testing conversion of {test_file}")
            
            base_name = os.path.splitext(test_file)[0]
            svg_file = base_name + ".svg"
            
            try:
                converter = CGMToSVGConverter(1200, 900)
                converter.convert_file(test_file, svg_file)
                print(f"  Created: {svg_file}")
            except Exception as e:
                print(f"  Error: {e}")
        else:
            print(f"Test file not found: {test_file}")


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        test_conversion()
    else:
        main()