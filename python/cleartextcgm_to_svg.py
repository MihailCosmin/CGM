#!/usr/bin/env python3
"""
Clear Text CGM to SVG Converter
Converts clear text CGM files to Scalable Vector Graphics (SVG) format

This converter parses clear text CGM files (as generated by our binary CGM converter)
and creates corresponding SVG files that can be viewed in web browsers or graphics applications.

Usage:
    python cleartextcgm_to_svg.py input.CGM output.svg
    python cleartextcgm_to_svg.py input.CGM  # outputs to input.svg

Supported CGM Commands:
- BEGMF, BEGPIC, BEGPICBODY (structure)
- vdcext (viewport/coordinate system)
- LINE (polylines)
- DISJTLINE (disjoint polylines)
- TEXT (text elements)
- POLYGON (filled polygons)
- linewidth, linetype, linecolr (line attributes)
- textfontindex, charheight, textcolr (text attributes)
- fillcolr (fill attributes)

Color Support:
- Indexed colors (0-255)
- Direct RGB colors
- Default CGM color palette

Coordinate System:
- Automatically scales CGM coordinates to fit SVG viewport
- Preserves aspect ratio
- Configurable output dimensions
"""

import sys
import os
import re
from typing import List, Optional
from dataclasses import dataclass
from enum import Enum


class LineType(Enum):
    """CGM Line Types"""
    SOLID = 1
    DASH = 2
    DOT = 3
    DASH_DOT = 4
    DASH_DOT_DOT = 5


@dataclass
class Point:
    """2D Point"""
    x: float
    y: float
    
    def __str__(self):
        return f"{self.x},{self.y}"


@dataclass
class Color:
    """RGB Color"""
    def __init__(self, r: int = 0, g: int = 0, b: int = 0):
        self.r = r
        self.g = g
        self.b = b
    
    def to_hex(self) -> str:
        """Convert to hex color string"""
        return f"#{self.r:02x}{self.g:02x}{self.b:02x}"
    
    @classmethod
    def from_index(cls, index: int, color_table: dict[int, 'Color'] = None) -> 'Color':
        """Create color from CGM color index using custom table or standard palette"""
        # Check custom color table first
        if color_table and index in color_table:
            return color_table[index]
        
        # Fall back to standard CGM color palette
        palette = [
            (255, 255, 255),  # 0: White (background)
            (0, 0, 0),        # 1: Black (foreground)
            (255, 0, 0),      # 2: Red
            (0, 255, 0),      # 3: Green
            (0, 0, 255),      # 4: Blue
            (255, 255, 0),    # 5: Yellow
            (255, 0, 255),    # 6: Magenta
            (0, 255, 255),    # 7: Cyan
            (128, 128, 128),  # 8: Gray
            (192, 192, 192),  # 9: Light Gray
            (128, 0, 0),      # 10: Dark Red
            (0, 128, 0),      # 11: Dark Green
            (0, 0, 128),      # 12: Dark Blue
            (128, 128, 0),    # 13: Dark Yellow
            (128, 0, 128),    # 14: Dark Magenta
            (0, 128, 128),    # 15: Dark Cyan
        ]
        
        if 0 <= index < len(palette):
            r, g, b = palette[index]
        else:
            # Generate a color for higher indices
            r = (index * 37) % 256
            g = (index * 73) % 256
            b = (index * 109) % 256
        
        return cls(r, g, b)


class GraphicsState:
    """Current graphics state"""
    def __init__(self):
        # Color table for custom color definitions
        self.color_table: dict = {}
        
        self.line_width: float = 1.0
        self.line_type: LineType = LineType.SOLID
        self.line_color: Color = Color(0, 0, 0)  # Black
        self.text_color: Color = Color(0, 0, 0)  # Black
        self.fill_color: Color = Color(255, 255, 255)  # White
        self.text_font_index: int = 1
        self.character_height: float = 12.0
        self.background_color: Color = Color(255, 255, 255)  # White
        self.edge_visible: bool = True
        self.edge_width: float = 1.0  # Edge width for closed shapes
        self.edge_color: Color = Color(0, 0, 0)  # Black
        self.interior_style: str = "hollow"  # hollow, solid, pattern, hatch, empty
        # Character orientation: (up_x, up_y), (base_x, base_y)
        self.char_orientation: tuple = ((0.0, 1.0), (1.0, 0.0))
        # Text alignment
        self.text_align_horiz: str = 'ctr'  # Horizontal alignment
        self.text_align_vert: str = 'base'  # Vertical alignment


class CGMToSVGConverter:
    """Converts clear text CGM to SVG"""
    
    def __init__(self, width: int = 800, height: int = 600):
        self.svg_width = width
        self.svg_height = height
        self.elements: List[str] = []
        self.state = GraphicsState()
        
        # CGM coordinate system
        self.vdc_extent_min = Point(0, 0)
        self.vdc_extent_max = Point(1000, 1000)
        
        # Font mapping
        self.font_families = {
            1: "Arial, sans-serif",
            2: "Times, serif",
            3: "Courier, monospace",
            14: "Arial, sans-serif",  # Common in technical drawings
        }
        
        # Grouping and optimization
        self.current_group_attributes = None
        self.pending_lines = []  # For consolidating into polylines
        self.groups = {}  # Layer/group organization
    
    def _get_scale(self) -> float:
        """Get the scaling factor from VDC to SVG coordinates"""
        # Use the standard scale of 39.37 (1000mm per inch / 25.4mm per inch)
        # This matches commercial CGM viewers
        return 39.37
    
    def convert_file(self, cgm_path: str, svg_path: str):
        """Convert CGM file to SVG"""
        with open(cgm_path, 'r', encoding='cp1252') as f:
            content = f.read()
        
        lines = content.split('\n')
        
        # First pass: parse metadata commands only
        original_vdc_min = None
        original_vdc_max = None
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line:
                continue
            
            # Remove trailing semicolon if present
            if line.endswith(';'):
                line = line[:-1]
            
            # Only parse VDC extent commands in first pass
            if line.startswith('vdcext') or line.startswith('MAXVDCEXT'):
                if original_vdc_min is None:  # Store the first vdcext found
                    original_vdc_min = self.vdc_extent_min
                    original_vdc_max = self.vdc_extent_max
                self._parse_command(line)
        
        # Auto-detect bounds and compare with parsed VDC extent
        parsed_min = self.vdc_extent_min
        parsed_max = self.vdc_extent_max
        self._auto_detect_bounds(content)
        
        # If auto-detection found significantly different bounds, use those instead
        auto_width = self.vdc_extent_max.x - self.vdc_extent_min.x
        auto_height = self.vdc_extent_max.y - self.vdc_extent_min.y
        parsed_width = parsed_max.x - parsed_min.x if parsed_max else 1000
        parsed_height = parsed_max.y - parsed_min.y if parsed_max else 1000
        
        # If auto-detected bounds are significantly larger, use them
        if auto_width > parsed_width * 10 or auto_height > parsed_height * 10:
            print(f"Using auto-detected bounds: ({self.vdc_extent_min.x}, {self.vdc_extent_min.y}) to ({self.vdc_extent_max.x}, {self.vdc_extent_max.y})")
        else:
            # Restore parsed bounds  
            self.vdc_extent_min = parsed_min
            self.vdc_extent_max = parsed_max
            print(f"Using parsed VDC extent: ({self.vdc_extent_min.x}, {self.vdc_extent_min.y}) to ({self.vdc_extent_max.x}, {self.vdc_extent_max.y})")
        
        # Second pass: parse all commands (skip VDC extent commands)
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line:
                continue
            
            # Remove trailing semicolon if present
            if line.endswith(';'):
                line = line[:-1]
            
            # Skip VDC extent commands in second pass to preserve auto-detected bounds
            if line.startswith('vdcext') or line.startswith('MAXVDCEXT'):
                continue
            
            self._parse_command(line)
        
        # Generate and write SVG
        self._write_svg(svg_path)

    def _write_svg(self, svg_path: str):
        """Write the SVG content to file"""
        # Flush any pending lines before writing
        self._flush_pending_lines()
        
        # Calculate viewBox based on the new coordinate system
        cgm_width = self.vdc_extent_max.x - self.vdc_extent_min.x
        cgm_height = self.vdc_extent_max.y - self.vdc_extent_min.y
        
        # Use larger scale for readable text (similar to commercial software)
        # Target viewbox width of ~6800 for good text rendering
        scale = self._get_scale()
        viewbox_width = cgm_width * scale
        viewbox_height = cgm_height * scale
        
        # Physical dimensions in inches (1000 viewbox units = 1 inch)
        # This matches commercial CGM software output
        physical_width = viewbox_width / 1000  # inches
        physical_height = viewbox_height / 1000  # inches
        
        svg_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<svg width="{physical_width:.5f}in" height="{physical_height:.5f}in" 
     viewBox="0 0 {viewbox_width:.1f} {viewbox_height:.1f}"
     xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style type="text/css">
      polyline {{ stroke-linejoin: round; stroke-linecap: round; fill: none; }}
      path {{ stroke-linejoin: round; stroke-linecap: round; fill: none; }}
    </style>
  </defs>
  <!-- Generated from CGM by cleartextcgm_to_svg.py -->
  <g id="cgm-content">
"""
        
        # Add all elements
        for element in self.elements:
            svg_content += f"    {element}\n"
        
        svg_content += """  </g>
</svg>"""
        
        with open(svg_path, 'w', encoding='utf-8') as f:
            f.write(svg_content)

    def _auto_detect_bounds(self, content: str):
        """Auto-detect coordinate bounds from drawing commands"""
        all_coords = []
        
        # Extract all coordinate values from LINE, CIRCLE, etc.
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            if any(line.startswith(cmd) for cmd in ['LINE', 'CIRCLE', 'ARCCTR', 'RESTRTEXT']):
                coords = re.findall(r'([-+]?[\d.]+)', line)
                # Take pairs of coordinates (x,y)
                for i in range(0, len(coords) - 1, 2):
                    try:
                        x, y = float(coords[i]), float(coords[i + 1])
                        all_coords.append((x, y))
                    except (ValueError, IndexError):
                        continue
        
        if all_coords:
            xs, ys = zip(*all_coords)
            min_x, max_x = min(xs), max(xs)
            min_y, max_y = min(ys), max(ys)
            
            # Add some padding
            padding = max((max_x - min_x), (max_y - min_y)) * 0.1
            
            # Override VDC extent with actual bounds
            self.vdc_extent_min = Point(min_x - padding, min_y - padding)
            self.vdc_extent_max = Point(max_x + padding, max_y + padding)
    
    def _parse_cgm(self, content: str):
        """Parse clear text CGM content"""
        lines = content.split('\n')
        
        # Join multi-line commands (lines ending with comma)
        joined_lines = []
        current_line = ""
        for line in lines:
            line = line.strip()
            if not line or line.startswith('%'):
                continue
            
            # Accumulate lines that end with comma
            if current_line:
                current_line += " " + line
            else:
                current_line = line
            
            # If line doesn't end with comma, it's complete
            if not line.endswith(','):
                joined_lines.append(current_line)
                current_line = ""
        
        # Parse joined lines
        for line in joined_lines:
            # Remove trailing semicolon
            if line.endswith(';'):
                line = line[:-1]
            
            self._parse_command(line)
    
    def _parse_command(self, line: str):
        """Parse a single CGM command"""
        # Handle different command types
        if line.startswith('BEGMF'):
            self._parse_begin_metafile(line)
        elif line.startswith('BEGPIC'):
            self._parse_begin_picture(line)
        elif line.startswith('vdcext'):
            self._parse_vdc_extent(line)
        elif line.startswith('MAXVDCEXT'):
            self._parse_max_vdc_extent(line)
        elif line.startswith('LINE'):
            self._parse_line(line)
        elif line.startswith('DISJTLINE'):
            self._parse_disjoint_line(line)
        elif line.startswith('TEXT'):
            self._parse_text(line)
        elif line.startswith('POLYGON'):
            self._parse_polygon(line)
        elif line.startswith('linewidth'):
            self._parse_line_width(line)
        elif line.startswith('linetype'):
            self._parse_line_type(line)
        elif line.startswith('linecolr'):
            self._parse_line_color(line)
        elif line.startswith('textcolr'):
            self._parse_text_color(line)
        elif line.startswith('fillcolr'):
            self._parse_fill_color(line)
        elif line.startswith('textfontindex'):
            self._parse_text_font_index(line)
        elif line.startswith('charheight'):
            self._parse_character_height(line)
        elif line.startswith('CIRCLE'):
            self._parse_circle(line)
        elif line.startswith('ELLIPSE'):
            self._parse_ellipse(line)
        elif line.startswith('ARCCTR'):
            self._parse_arc_center(line)
        elif line.startswith('ELLIPARC'):
            self._parse_elliptical_arc(line)
        elif line.startswith('RESTRTEXT'):
            self._parse_restricted_text(line)
        elif line.startswith('COLRTABLE') or line.startswith('colrtable'):
            self._parse_color_table(line)
        elif line.startswith('edgevis'):
            self._parse_edge_visibility(line)
        elif line.startswith('EDGEWIDTH'):
            self._parse_edge_width(line)
        elif line.startswith('EDGECOLR'):
            self._parse_edge_color(line)
        elif line.startswith('intstyle'):
            self._parse_interior_style(line)
        elif line.startswith('BEGPICBODY'):
            pass  # Picture body start - no action needed
        elif line.startswith('ENDPIC'):
            pass  # End picture - no action needed
        elif line.startswith('ENDMF'):
            pass  # End metafile - no action needed
        elif line.startswith('MESSAGE'):
            pass  # Message command - ignore for rendering
        elif line.startswith('CLIP'):
            self._parse_clip(line)
        elif line.startswith(('charori', 'CHARORI')):
            self._parse_character_orientation(line)
        elif line.startswith(('textalign', 'TEXTALIGN')):
            self._parse_text_alignment(line)
        elif line.startswith('LINECAP'):
            self._parse_line_cap(line)
        elif line.startswith('LINEJOIN'):
            self._parse_line_join(line)
        elif line.startswith('EDGECOLR'):
            self._parse_edge_color(line)
        elif line.startswith('EDGEWIDTH'):
            self._parse_edge_width(line)
        elif line.startswith('intstyle'):
            self._parse_interior_style(line)
        # Ignore setup commands that don't affect rendering directly
        elif line.startswith(('MFVERSION', 'MFDESC', 'MFELEMLIST', 'fontlist', 
                             'CHARSETLIST', 'VDCTYPE', 'COLRPREC', 'COLRINDEXPREC',
                             'COLRVALUEEXT', 'MAXCOLRINDEX', 'INTEGERPREC', 'REALPREC',
                             'charcoding', 'MAXVDCEXT', 'scalemode', 'colrmode',
                             'EDGEWIDTHMODE', 'VDCREALPREC', 'linewidthmode',
                             'ALTCHARSETINDEX', 'CHARSETINDEX', 'HATCHSTYLEDEF',
                             'PATTERNDEFN', 'INTERPINT', 'TRANSPARENCY', 'EDGETYPE',
                             'EDGEVIS', 'backcolr')):
            pass  # Setup commands - ignore for rendering
        # Add more command parsers as needed
    
    def _parse_begin_metafile(self, line: str):
        """Parse BEGMF command"""
        # Extract title if present
        match = re.search(r"'([^']*)'", line)
        if match:
            title = match.group(1)
            # Sanitize title for XML comments (replace -- with - -)
            safe_title = title.replace('--', '- -')
            self.elements.append(f'<!-- Metafile: {safe_title} -->')
    
    def _parse_begin_picture(self, line: str):
        """Parse BEGPIC command"""
        # Extract picture name if present
        match = re.search(r"'([^']*)'", line)
        if match:
            picture_name = match.group(1)
            # Sanitize picture name for XML comments (replace -- with - -)
            safe_name = picture_name.replace('--', '- -')
            self.elements.append(f'<!-- Picture: {safe_name} -->')
    
    def _parse_vdc_extent(self, line: str):
        """Parse vdcext command to set coordinate system"""
        # Extract coordinates: vdcext (x1,y1) (x2,y2)
        coords = re.findall(r'\(([^)]+)\)', line)
        if len(coords) >= 2:
            x1, y1 = map(float, coords[0].split(','))
            x2, y2 = map(float, coords[1].split(','))
            self.vdc_extent_min = Point(x1, y1)
            self.vdc_extent_max = Point(x2, y2)
    
    def _parse_line(self, line: str):
        """Parse LINE command - line or polyline by point count"""
        points = self._extract_points(line)
        if len(points) < 2:
            return
        
        style = self._get_line_style()
        
        if len(points) == 2:
            # Two points: use <line> element (matches commercial)
            p1 = self._transform_point(points[0])
            p2 = self._transform_point(points[1])
            
            line_element = (
                f'<line x1="{p1.x:.2f}" y1="{p1.y:.2f}" '
                f'x2="{p2.x:.2f}" y2="{p2.y:.2f}" '
                f'{style} fill="none"/>')
            self.elements.append(line_element)
        else:
            # Three or more points: use <polyline> with ALL points
            svg_points = [self._transform_point(p) for p in points]
            points_str = ' '.join([f'{p.x:.2f},{p.y:.2f}'
                                  for p in svg_points])
            
            polyline_element = (
                f'<polyline points="{points_str}" '
                f'{style} fill="none"/>')
            self.elements.append(polyline_element)
    
    def _flush_pending_lines(self):
        """Flush pending line segments as a consolidated polyline"""
        if len(self.pending_lines) < 2:
            self.pending_lines = []
            return
        
        # Transform all points
        svg_points = [self._transform_point(p) for p in self.pending_lines]
        
        # Create polyline element
        points_str = ' '.join([f'{p.x:.2f},{p.y:.2f}' for p in svg_points])
        style = self.current_group_attributes or self._get_line_style()
        
        polyline_element = f'<polyline points="{points_str}" {style} fill="none"/>'
        self.elements.append(polyline_element)
        
        self.pending_lines = []
    
    def _parse_line_original(self, line: str):
        """Original LINE parsing (kept for reference)"""
        points = self._extract_points(line)
        if len(points) < 2:
            return
        
        svg_points = [self._transform_point(p) for p in points]
        path_data = f"M {svg_points[0]}"
        for point in svg_points[1:]:
            path_data += f" L {point}"
        
        style = self._get_line_style()
        self.elements.append(f'<path d="{path_data}" {style} fill="none"/>')
    
    def _parse_disjoint_line(self, line: str):
        """Parse DISJTLINE command (multiple separate line segments)"""
        points = self._extract_points(line)
        if len(points) < 2:
            return
        
        style = self._get_line_style()
        
        # Draw line segments (every 2 points form a segment)
        for i in range(0, len(points) - 1, 2):
            if i + 1 < len(points):
                p1 = self._transform_point(points[i])
                p2 = self._transform_point(points[i + 1])
                path_data = f"M {p1} L {p2}"
                path_element = f'<path d="{path_data}" {style} fill="none"/>'
                self.elements.append(path_element)
    
    def _parse_text(self, line: str):
        """Parse TEXT command"""
        # Extract position and text: TEXT (x,y) final 'text'
        coord_match = re.search(r'\(([^)]+)\)', line)
        text_match = re.search(r"'([^']*)'", line)
        
        if coord_match and text_match:
            x, y = map(float, coord_match.group(1).split(','))
            text_content = text_match.group(1)
            
            svg_point = self._transform_point(Point(x, y))
            font_family = self.font_families.get(
                self.state.text_font_index, "Arial, sans-serif")
            
            # Calculate font size - use character height with same scale
            # as coordinates
            font_size = self.state.character_height * self._get_scale()
            
            text_style = (f'fill="{self.state.text_color.to_hex()}" '
                          f'font-family="{font_family}" '
                          f'font-size="{font_size}px"')
            
            # Escape XML special characters
            # Escape XML special characters
            text_content = (text_content.replace('&', '&amp;')
                            .replace('<', '&lt;').replace('>', '&gt;'))
            
            text_element = (f'<text x="{svg_point.x}" y="{svg_point.y}" '
                            f'{text_style}>{text_content}</text>')
            self.elements.append(text_element)
    
    def _parse_polygon(self, line: str):
        """Parse POLYGON command"""
        points = self._extract_points(line)
        if len(points) < 3:
            return
        
        svg_points = [self._transform_point(p) for p in points]
        points_str = ' '.join(str(p) for p in svg_points)
        
        line_style = self._get_line_style()
        
        # Check interior style for fill
        if self.state.interior_style in ["hollow", "empty"]:
            fill_style = 'fill="none"'
        else:
            fill_style = f'fill="{self.state.fill_color.to_hex()}"'
        
        polygon_element = (f'<polygon points="{points_str}" '
                           f'{line_style} {fill_style}/>')
        self.elements.append(polygon_element)
    
    def _parse_line_width(self, line: str):
        """Parse linewidth command"""
        match = re.search(r'linewidth\s+([\d.]+)', line)
        if match:
            self.state.line_width = float(match.group(1))
    
    def _parse_line_type(self, line: str):
        """Parse linetype command"""
        match = re.search(r'linetype\s+(\d+)', line)
        if match:
            line_type_num = int(match.group(1))
            try:
                self.state.line_type = LineType(line_type_num)
            except ValueError:
                self.state.line_type = LineType.SOLID
    
    def _parse_line_color(self, line: str):
        """Parse linecolr command"""
        color = self._parse_color(line)
        if color:
            self.state.line_color = color
    
    def _parse_text_color(self, line: str):
        """Parse textcolr command"""
        color = self._parse_color(line)
        if color:
            self.state.text_color = color
    
    def _parse_fill_color(self, line: str):
        """Parse fillcolr command"""
        color = self._parse_color(line)
        if color:
            self.state.fill_color = color
    
    def _parse_text_font_index(self, line: str):
        """Parse textfontindex command"""
        match = re.search(r'textfontindex\s+(\d+)', line)
        if match:
            self.state.text_font_index = int(match.group(1))
    
    def _parse_character_height(self, line: str):
        """Parse charheight command"""
        match = re.search(r'charheight\s+([\d.]+)', line)
        if match:
            self.state.character_height = float(match.group(1))

    def _parse_circle(self, line: str):
        """Parse CIRCLE command"""
        # Extract coordinates: CIRCLE cx cy radius
        coords = re.findall(r'([-+]?[\d.]+)', line)
        if len(coords) >= 3:
            cx, cy, radius = map(float, coords[:3])
            center = Point(cx, cy)
            svg_center = self._transform_point(center)
            
            # Transform radius with scale (don't use _transform_length
            # as it has line width correction that shouldn't apply)
            scale = self._get_scale()
            svg_radius = radius * scale
            
            # Use edge style for circles (not line style)
            style = self._get_edge_style()
            # Check interior style for fill
            if self.state.interior_style == "solid":
                # Solid fill - use fill color
                style += f' fill="{self.state.fill_color.to_hex()}"'
            else:
                # Hollow, empty, or other - no fill
                style += ' fill="none"'
            
            circle = (
                f'<circle cx="{svg_center.x:.2f}" '
                f'cy="{svg_center.y:.2f}" '
                f'r="{svg_radius:.2f}" {style}/>')
            self.elements.append(circle)

    def _parse_ellipse(self, line: str):
        """Parse ELLIPSE command: ELLIPSE (cx,cy) (cdp1x,cdp1y) (cdp2x,cdp2y)"""
        # Extract coordinate points
        points = self._extract_points(line)
        if len(points) >= 3:
            center = points[0]
            cdp1 = points[1]  # Conjugate diameter point 1
            cdp2 = points[2]  # Conjugate diameter point 2
            
            # Calculate semi-major and semi-minor axes from conjugate diameter points
            rx = abs(cdp1.x - center.x)
            ry = abs(cdp2.y - center.y)
            
            svg_center = self._transform_point(center)
            svg_rx = self._transform_length(rx)
            svg_ry = self._transform_length(ry)
            
            # Use edge style for ellipses (not line style)
            style = self._get_edge_style()
            # Check interior style for fill
            if self.state.interior_style == "solid":
                # Solid fill - use fill color
                style += f' fill="{self.state.fill_color.to_hex()}"'
            else:
                # Hollow, empty, or other - no fill
                style += ' fill="none"'
            
            ellipse = f'<ellipse cx="{svg_center.x:.2f}" cy="{svg_center.y:.2f}" ' \
                     f'rx="{svg_rx:.2f}" ry="{svg_ry:.2f}" {style}/>'
            self.elements.append(ellipse)

    def _parse_arc_center(self, line: str):
        """Parse ARCCTR command (Arc Center)"""
        # Extract coordinates: ARCCTR cx cy dx1 dy1 dx2 dy2 radius
        coords = re.findall(r'([-+]?[\d.]+)', line)
        if len(coords) >= 7:
            cx, cy, dx1, dy1, dx2, dy2, radius = map(float, coords[:7])
            
            # Transform radius with scale
            scale = self._get_scale()
            svg_radius = radius * scale
            
            # Skip very small arcs (likely rendering artifacts)
            if svg_radius < 0.1:
                return
            
            # Calculate start and end points in CGM coordinates
            import math
            
            # Start point: center + (dx1, dy1)
            start_x = cx + dx1
            start_y = cy + dy1
            
            # End point: center + (dx2, dy2)
            end_x = cx + dx2
            end_y = cy + dy2
            
            # Transform points to SVG coordinates
            svg_start = self._transform_point(Point(start_x, start_y))
            svg_end = self._transform_point(Point(end_x, end_y))
            
            # Calculate angles in CGM coordinate system (before Y-flip)
            start_angle = math.atan2(dy1, dx1)
            end_angle = math.atan2(dy2, dx2)
            
            # Calculate angle difference (counter-clockwise is positive in CGM)
            angle_diff = end_angle - start_angle
            
            # Normalize to [0, 2π]
            while angle_diff < 0:
                angle_diff += 2 * math.pi
            while angle_diff > 2 * math.pi:
                angle_diff -= 2 * math.pi
            
            # Determine if this is a large arc (> 180 degrees)
            large_arc = 1 if angle_diff > math.pi else 0
            
            # Sweep direction: CGM has Y-up, SVG has Y-down (flipped).
            # In CGM: counter-clockwise is positive angle (mathematical convention)
            # In SVG: clockwise is positive (screen coordinates, Y-down)
            # When we flip Y: CGM counter-clockwise → SVG counter-clockwise
            # So use sweep=0 for positive CGM angles (counter-clockwise in both)
            sweep = 0 if angle_diff > 0 else 1
            
            # Create SVG arc using path with A command
            # A rx ry x-axis-rotation large-arc-flag sweep-flag x y
            style = self._get_line_style()
            path_data = (f"M {svg_start.x:.2f},{svg_start.y:.2f} "
                        f"A {svg_radius:.2f},{svg_radius:.2f} 0 "
                        f"{large_arc},{sweep} {svg_end.x:.2f},{svg_end.y:.2f}")
            
            arc_element = f'<path d="{path_data}" {style} fill="none"/>'
            self.elements.append(arc_element)

    def _parse_elliptical_arc(self, line: str):
        """Parse ELLIPARC command (Elliptical Arc)"""
        # ELLIPARC format: ELLIPARC (cx,cy) (cdp1x,cdp1y) (cdp2x,cdp2y) (dx1,dy1) (dx2,dy2)
        # where cdp1, cdp2 are conjugate diameter endpoints defining the ellipse
        # and (dx1,dy1), (dx2,dy2) are vectors from center to start/end of arc
        
        points = self._extract_points(line)
        if len(points) >= 5:
            center = points[0]
            cdp1 = points[1]  # Conjugate diameter point 1
            cdp2 = points[2]  # Conjugate diameter point 2
            start_vec = points[3]  # Start point vector (dx1, dy1)
            end_vec = points[4]  # End point vector (dx2, dy2)
            
            import math
            
            # Calculate conjugate diameter vectors from center
            cdp1_vec_x = cdp1.x - center.x
            cdp1_vec_y = cdp1.y - center.y
            cdp2_vec_x = cdp2.x - center.x
            cdp2_vec_y = cdp2.y - center.y
            
            # For conjugate diameters, calculate the semi-axes
            # The semi-axes are the magnitudes of the conjugate diameter vectors
            # divided by sqrt(2) (for a general ellipse)
            # But in CGM, the CDP points already represent the semi-axes
            rx = math.sqrt(cdp1_vec_x**2 + cdp1_vec_y**2)
            ry = math.sqrt(cdp2_vec_x**2 + cdp2_vec_y**2)
            
            # Calculate rotation angle from the first conjugate diameter
            rotation_angle = math.degrees(math.atan2(cdp1_vec_y, cdp1_vec_x))
            
            # When Y-axis is flipped, negate the rotation angle
            svg_rotation_angle = -rotation_angle
            
            # Transform to SVG coordinates
            scale = self._get_scale()
            svg_rx = rx * scale
            svg_ry = ry * scale
            
            # Calculate start and end points
            start_x = center.x + start_vec.x
            start_y = center.y + start_vec.y
            end_x = center.x + end_vec.x
            end_y = center.y + end_vec.y
            
            svg_start = self._transform_point(Point(start_x, start_y))
            svg_end = self._transform_point(Point(end_x, end_y))
            
            # Calculate angles for sweep direction
            start_angle = math.atan2(start_vec.y, start_vec.x)
            end_angle = math.atan2(end_vec.y, end_vec.x)
            
            angle_diff = end_angle - start_angle
            while angle_diff < 0:
                angle_diff += 2 * math.pi
            while angle_diff > 2 * math.pi:
                angle_diff -= 2 * math.pi
            
            # Determine flags
            large_arc = 1 if angle_diff > math.pi else 0
            sweep = 0 if angle_diff > 0 else 1
            
            # Create SVG elliptical arc with rotation
            style = self._get_line_style()
            path_data = (f"M {svg_start.x:.2f},{svg_start.y:.2f} "
                        f"A {svg_rx:.2f},{svg_ry:.2f} {svg_rotation_angle:.2f} "
                        f"{large_arc},{sweep} {svg_end.x:.2f},{svg_end.y:.2f}")
            
            arc_element = f'<path d="{path_data}" {style} fill="none"/>'
            self.elements.append(arc_element)


    def _parse_restricted_text(self, line: str):
        """Parse RESTRTEXT command (Restricted Text)"""
        # Extract: RESTRTEXT width height (x,y) final 'text'
        coords = re.findall(r'([-+]?[\d.]+)', line)
        text_match = re.search(r"'([^']*)'", line)
        
        if len(coords) >= 4 and text_match:
            # Correct order: width, height, x, y
            width, height, x, y = map(float, coords[:4])
            text = text_match.group(1)
            
            if text:  # Only render non-empty text
                scale = self._get_scale()
                
                # Get character orientation (base_x is rotation component)
                ((up_x, up_y), (base_x, base_y)) = \
                    self.state.char_orientation
                
                # Transform position to SVG coordinates (final position)
                position = Point(x, y)
                svg_pos = self._transform_point(position)
                
                # Calculate font size from height
                # Commercial uses ~138.56px for height=2.5356
                # So: font_size = height * scale * (138.56 / (2.5356 * 39.37))
                svg_height = height * scale * 1.388
                
                color = self.state.text_color.to_hex()
                
                # Check if text is rotated (base_x significantly different from 1.0)
                is_rotated = abs(base_x - 1.0) > 0.01
                
                if is_rotated:
                    # Rotated text: Use transform matrix approach
                    # Use standard y position (all text in commercial uses y=2204.72)
                    standard_y = 2204.72
                    
                    # Calculate text_x using formula: text_x = 2916.88 / base_x
                    # This is the average constant from commercial output
                    text_x = 2916.88 / base_x
                    
                    # Calculate translation to position text correctly
                    # Final X position should be: base_x * text_x + tx = svg_pos.x
                    tx = svg_pos.x - (base_x * text_x)
                    ty = svg_pos.y - standard_y
                    
                    # Match commercial format with transform matrix
                    # Format: matrix(scaleX skewY skewX scaleY translateX translateY)
                    text_elem = (
                        f'   <g transform="matrix({base_x:.6f} 0 0 1 '
                        f'{tx:.3f} {ty:.3f})">\n'
                        f'    <text x="{text_x:.2f}" '
                        f'y="{standard_y}" '
                        f'font-size="{svg_height:.2f}" '
                        f'text-anchor="middle" '
                        f'fill="{color}">'
                        f'{text}</text>\n'
                        f'   </g>')
                else:
                    # Non-rotated text: Use direct positioning
                    # Adjust Y position for vertical alignment
                    adjusted_y = svg_pos.y
                    if self.state.text_align_vert == 'half':
                        # 'half' means Y is at text middle, but SVG y is at baseline
                        # Move baseline down by ~40% of font height (approximation)
                        adjusted_y = svg_pos.y + (svg_height * 0.4)
                    
                    text_elem = (
                        f'<text x="{svg_pos.x:.2f}" '
                        f'y="{adjusted_y:.2f}" '
                        f'font-size="{svg_height:.2f}" '
                        f'text-anchor="middle" '
                        f'fill="{color}">' 
                        f'{text}</text>')
                
                self.elements.append(text_elem)

    def _parse_color_table(self, line: str):
        """Parse COLRTABLE/colrtable command"""
        # Format: colrtable start_index r g b, r g b, ...;
        # Example: colrtable 0 255 255 255, 0 0 0;
        
        # Remove command name and extract numbers
        content = line.replace('colrtable', '').replace('COLRTABLE', '')
        # Remove commas and semicolons for easier parsing
        content = content.replace(',', ' ').replace(';', '')
        numbers = [int(x) for x in content.split() if x.strip()]
        
        if len(numbers) >= 4:
            start_index = numbers[0]
            # Parse RGB triplets starting from index 1
            for i in range(1, len(numbers), 3):
                if i + 2 < len(numbers):
                    r, g, b = numbers[i], numbers[i+1], numbers[i+2]
                    color_index = start_index + (i - 1) // 3
                    self.state.color_table[color_index] = Color(r, g, b)

    def _parse_clip(self, line: str):
        """Parse CLIP command"""
        # CLIP on/off - for now just ignore
        pass

    def _parse_character_orientation(self, line: str):
        """Parse CHARORI command (Character Orientation)"""
        # Format: CHARORI up_x up_y, base_x base_y
        # Example: CHARORI 0.0000 1.0000, 0.9735 0.0000
        coords = re.findall(r'([-+]?[\d.]+)', line)
        if len(coords) >= 4:
            up_x, up_y, base_x, base_y = map(float, coords[:4])
            self.state.char_orientation = ((up_x, up_y), (base_x, base_y))

    def _parse_text_alignment(self, line: str):
        """Parse TEXTALIGN command"""
        # Format: textalign horiz, vert, horiz_offset, vert_offset
        # horiz: normhoriz, left, ctr, right, conthoriz
        # vert: normvert, top, cap, half, base, bottom, contvert
        parts = line.lower().replace('textalign', '').strip().split(',')
        if len(parts) >= 2:
            horiz = parts[0].strip()
            vert = parts[1].strip()
            self.state.text_align_horiz = horiz
            self.state.text_align_vert = vert

    def _parse_line_cap(self, line: str):
        """Parse LINECAP command"""
        # Line cap style - for now just ignore
        pass

    def _parse_line_join(self, line: str):
        """Parse LINEJOIN command"""
        # Line join style - for now just ignore
        pass

    def _parse_edge_color(self, line: str):
        """Parse EDGECOLR command"""
        coords = re.findall(r'([\d.]+)', line)
        if len(coords) >= 3:
            r, g, b = map(int, coords[:3])
            self.state.edge_color = Color(r, g, b)
        elif len(coords) >= 1:
            # Single value - use color index
            index = int(coords[0])
            self.state.edge_color = Color.from_index(index)

    def _parse_edge_visibility(self, line: str):
        """Parse edgevis command"""
        # edgevis on|off
        if 'on' in line.lower():
            self.state.edge_visible = True
        elif 'off' in line.lower():
            self.state.edge_visible = False

    def _parse_edge_width(self, line: str):
        """Parse EDGEWIDTH command"""
        coords = re.findall(r'([\d.]+)', line)
        if coords:
            self.state.edge_width = float(coords[0])

    def _parse_interior_style(self, line: str):
        """Parse INTSTYLE command"""
        # INTSTYLE hollow|solid|pattern|hatch|empty
        parts = line.split()
        if len(parts) >= 2:
            style = parts[1].lower()
            self.state.interior_style = style
            # Note: fill_color is set separately by FILLCOLR command
            # interior_style just controls whether to use it

    def _parse_max_vdc_extent(self, line: str):
        """Parse MAXVDCEXT command to set maximum coordinate system"""
        # Extract coordinates: MAXVDCEXT x1 y1 x2 y2
        coords = re.findall(r'([-+]?[\d.]+)', line)
        if len(coords) >= 4:
            x1, y1, x2, y2 = map(float, coords[:4])
            # Use MAXVDCEXT as fallback if no specific vdcext was set
            if (self.vdc_extent_min.x == 0 and self.vdc_extent_min.y == 0 and
                self.vdc_extent_max.x == 800 and self.vdc_extent_max.y == 600):
                self.vdc_extent_min = Point(x1, y1)
                self.vdc_extent_max = Point(x2, y2)
    
    def _parse_color(self, line: str) -> Optional[Color]:
        """Parse color specification (indexed or direct RGB)"""
        # Try indexed color first: colorcommand 5 or colorcommand 5;
        index_match = re.search(r'\s+(\d+)\s*;?\s*$', line)
        if index_match:
            index = int(index_match.group(1))
            return Color.from_index(index, self.state.color_table)
        
        # Try direct RGB: colorcommand 255 128 64 or colorcommand 255 128 64;
        rgb_match = re.search(r'\s+(\d+)\s+(\d+)\s+(\d+)\s*;?\s*$', line)
        if rgb_match:
            r, g, b = map(int, rgb_match.groups())
            return Color(r, g, b)
        
        return None
    
    def _extract_points(self, line: str) -> List[Point]:
        """Extract coordinate points from a line"""
        points = []
        # Find all coordinate pairs in parentheses
        coords = re.findall(r'\(([^)]+)\)', line)
        for coord in coords:
            try:
                x, y = map(float, coord.split(','))
                points.append(Point(x, y))
            except (ValueError, IndexError):
                continue
        return points
    
    def _transform_point(self, cgm_point: Point) -> Point:
        """Transform CGM coordinates to SVG coordinates"""
        # Use a simple scale factor to get reasonable coordinate values
        # Aim for a viewBox around 100-500 units wide
        cgm_width = self.vdc_extent_max.x - self.vdc_extent_min.x
        cgm_height = self.vdc_extent_max.y - self.vdc_extent_min.y
        
        if cgm_width <= 0 or cgm_height <= 0:
            return Point(0, 0)
        
        # Scale using consistent method
        scale = self._get_scale()
        
        # Transform coordinates relative to minimum point
        x = (cgm_point.x - self.vdc_extent_min.x) * scale
        y = (cgm_point.y - self.vdc_extent_min.y) * scale
        
        # Flip Y axis (CGM has origin at bottom-left, SVG at top-left)
        viewbox_height = cgm_height * scale
        y = viewbox_height - y
        
        return Point(x, y)
    
    def _transform_length(self, cgm_length: float) -> float:
        """Transform CGM length to SVG length"""
        cgm_width = self.vdc_extent_max.x - self.vdc_extent_min.x
        
        if cgm_width <= 0:
            return cgm_length
        
        # Use same scale as coordinate transformation
        scale = self._get_scale()
        
        # Apply scale directly without any corrections
        transformed_width = cgm_length * scale
        
        return transformed_width
    
    def _get_edge_style(self) -> str:
        """Generate SVG style for edges (circles, ellipses, etc)"""
        # Check if edge is visible
        if not self.state.edge_visible:
            return 'stroke="none"'
        
        width = self._transform_length(self.state.edge_width)
        color = self.state.edge_color.to_hex()
        return f'stroke="{color}" stroke-width="{width:.2f}"'
    
    def _get_line_style(self) -> str:
        """Generate SVG style string for current line attributes"""
        width = self._transform_length(self.state.line_width)
        
        # Enforce minimum line width of 3px for visibility (matches commercial behavior)
        if width < 3.0:
            width = 3.0
        
        color = self.state.line_color.to_hex()
        
        # Handle line types
        if self.state.line_type == LineType.SOLID:
            stroke_dasharray = "none"
        elif self.state.line_type == LineType.DASH:
            dash_length = width * 4
            stroke_dasharray = f"{dash_length},{dash_length}"
        elif self.state.line_type == LineType.DOT:
            dot_length = width
            stroke_dasharray = f"{dot_length},{dot_length}"
        elif self.state.line_type == LineType.DASH_DOT:
            dash_length = width * 4
            dot_length = width
            stroke_dasharray = f"{dash_length},{dot_length},{dot_length},{dot_length}"
        elif self.state.line_type == LineType.DASH_DOT_DOT:
            dash_length = width * 4
            dot_length = width
            stroke_dasharray = f"{dash_length},{dot_length},{dot_length},{dot_length},{dot_length},{dot_length}"
        else:
            stroke_dasharray = "none"
        
        style = f'stroke="{color}" stroke-width="{width:.2f}"'
        if stroke_dasharray != "none":
            style += f' stroke-dasharray="{stroke_dasharray}"'
        
        return style
    
    def _generate_svg(self) -> str:
        """Generate complete SVG content"""
        svg_header = f'''<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="{self.svg_width}" height="{self.svg_height}"
     viewBox="0 0 {self.svg_width} {self.svg_height}">
<!-- Generated from Clear Text CGM -->
<rect width="{self.svg_width}" height="{self.svg_height}" 
      fill="{self.state.background_color.to_hex()}"/>
'''
        
        svg_footer = '</svg>'
        
        return svg_header + '\n'.join(self.elements) + '\n' + svg_footer


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: python cleartextcgm_to_svg.py <input.CGM> [output.svg] [width] [height]")
        print("\\nExample:")
        print("  python cleartextcgm_to_svg.py techdraw_cleartext.CGM techdraw.svg")
        print("  python cleartextcgm_to_svg.py drawing.CGM drawing.svg 1200 800")
        print("  python cleartextcgm_to_svg.py drawing.CGM  # creates drawing.svg")
        sys.exit(1)
    
    input_file = sys.argv[1]
    
    # Check if input file exists
    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' not found!")
        sys.exit(1)
    
    # Determine output filename
    if len(sys.argv) >= 3:
        output_file = sys.argv[2]
    else:
        # Replace extension with .svg
        base_name = os.path.splitext(input_file)[0]
        output_file = base_name + ".svg"
    
    # Get dimensions
    width = int(sys.argv[3]) if len(sys.argv) >= 4 else 800
    height = int(sys.argv[4]) if len(sys.argv) >= 5 else 600
    
    print(f"Converting Clear Text CGM to SVG:")
    print(f"  Input:      {input_file}")
    print(f"  Output:     {output_file}")
    print(f"  Dimensions: {width} x {height}")
    print()
    
    try:
        # Perform conversion
        converter = CGMToSVGConverter(width, height)
        converter.convert_file(input_file, output_file)
        
        print(f"Conversion completed successfully!")
        print(f"SVG file written to: {output_file}")
        
        # Report statistics
        with open(output_file, 'r') as f:
            svg_content = f.read()
            element_count = svg_content.count('<path') + svg_content.count('<text') + svg_content.count('<polygon')
            print(f"Generated {element_count} SVG elements")
        
    except Exception as e:
        print(f"Error during conversion: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def test_conversion():
    """Test the conversion with sample CGM files"""
    test_files = [
        "tests/00003/techdraw_cleartext.CGM",
        "tests/00003/ICN-AFGA08298XX-A-252001-A-D1131-00007-A-01-1_cleartext.CGM"
    ]
    
    for test_file in test_files:
        if os.path.exists(test_file):
            print(f"Testing conversion of {test_file}")
            
            base_name = os.path.splitext(test_file)[0]
            svg_file = base_name + ".svg"
            
            try:
                converter = CGMToSVGConverter(1200, 900)
                converter.convert_file(test_file, svg_file)
                print(f"  Created: {svg_file}")
            except Exception as e:
                print(f"  Error: {e}")
        else:
            print(f"Test file not found: {test_file}")


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--test":
        test_conversion()
    else:
        main()